# source for figuring out ode: https://flothesof.github.io/charged-particle-trajectories-E-and-B-fields.html

# general imports:
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

import scipy
from scipy.integrate import ode
from scipy.integrate import solve_ivp
from matplotlib import animation
from matplotlib.animation import FuncAnimation

'''Tom: Use the Particles class instead'''
from Particles import Particles

'''Tom: Coulomb's constant'''
COULOMBS_CONSTANT = 8.99*(10**9)

#-------------------------------------------------------------------------------------------------------------------------------------------
# basically, we want to store a positions and velocities matrix for each particle we simulate
# setting things up (STARTING WITH 3 ARBITRARY PARTICLES):
'''eventually get to 5-6 particles'''

# SETUP:
num_steps=10 # arbitrary
pos_1=np.zeros((num_steps, 3)) # array of positions for first particle for all timesteps (stepsx3)
pos_1[0]=np.array([0, 0, 0]) # initial position of particle 1
vel_1=np.zeros((num_steps, 3)) # array of velocities for first particle for all timesteps
vel_1[0]=np.array([1, 1, 0]) # initial velocity of particle 1
q1=1 # C
m1=3 # kg

pos_2=np.zeros((num_steps, 3))
pos_2[0]=np.array([1, 1, 0]) 
vel_2=np.zeros((num_steps, 3))
vel_2[0]=np.array([0, 0, 0])
q2=1 # C
m2=1 # kg

pos_3=np.zeros((num_steps, 3))
pos_3[0]=np.array([0, 1, 1])
vel_3=np.zeros((num_steps, 3)) 
vel_3[0]=np.array([1, 0, 1])
q3=-1.5 # C
m3=2 # kg
#-------------------------------------------------------------------------------------------------------------------------------------------
''' eventually, all of the following will be put into a loop through each particle, which is nested in a larger
    loop for each time step'''

'''Tom:
Why is this function returning the external fields?
That should be handled by other functions(such as user inputs). It's not doing any computation with the external fields.
You can add the fields generated by particles to the external fields and return that instead.
'''
def get_fields(pos_part, pos_other1, pos_other2, q1, q_other1, q_other2, step): 
    ''' takes in the position of the desired particle (1xsteps*3), positions of the other particles and the other charges (Nx1)
        and the step'''

    x_all, y_all, z_all=list(zip(pos_part[step],pos_other1[step],pos_other2[step]))
    # gives an array where the first set of 3 is x_1, x_2, x_3, the second set is y_1, y_2, y_3, last set is z_1, z_2, z_3 for desired time
    q_all=list([q1,q_other1,q_other2])
    
    x1, y1, z1=x_all[0], y_all[0], z_all[0] # position of desired particle (floats) @ t0
    xothers=np.array([x_all[1], x_all[2]]) # positions of the other particles in the system @ t0
    yothers=np.array([y_all[1], y_all[2]])
    zothers=np.array([z_all[1], z_all[2]])
 
    # here we define what we want E and B to be (that we're externally setting up)
    E_ext=np.array([1, (x1**2)+2, 2*y1]) # sample choice
    # B_ind= we reach steady state; cascates down the road and becomes complicated; if we don't include induced it's not going to be major
    # magentic fields that are induced are not conservative (this is a problem and have to deal with them differently, can't apply 
    # conservation laws
    B_ext=np.array([z1, 0, 3*x1]) # sample choice
    # E_ind=

    # we also need to consider the E fields being created by the other points
    E_points=0 # initially E from the other points is 0
    
    for particle in range(1, len(q_all)): # going through the other points generated and finding the field they create
        x2, y2, z2=xothers[particle-1], yothers[particle-1], zothers[particle-1] # go down one index b/c x others is already isolated to
                                                                                 # the non-desired particles
        '''
        Tom: It's better to use constants from libraries or declare it on the top of the file. It's also a convention
        to name constants with capital letters to void people from accidentally reassigning the constants.
        '''
        q=q_all[particle]
        k=8.99*(10**9) # N*m^2/C--Coulomb's constant
        dist=np.sqrt(((x2-x1)**2)+((y2-y1)**2)+((z2-z1)**2))
        E_points+=k*q/(dist**2)
    # E_points that gets returned is the sum of all of the fields generated by the other particles
    
    return E_ext, B_ext, E_points # returns the fields at the start of the timestep (t0)

Fields1= get_fields(pos_1, pos_2, pos_3, q1, q2, q3, 0) # works as expected for Particle 1 so far--eventually put into particle loop and get all of them
Fields2= get_fields(pos_2, pos_3, pos_1, q2, q3, q1, 0) # works as expected for Particle 2 so far
Fields3= get_fields(pos_3, pos_1, pos_2, q3, q1, q2, 0) # works as expected for Particle 3

'''
Tom: just print some stuff
'''
#print(Fields1, Fields2, Fields3)

'''
Tom: Suggested modifications:
(please let me know what you think)
'''
'''
Tom: You can explicitly require types in newer versions of python. Static typing can reduce errors
and improve readability.
'''
def get_fields2(particles: Particles) -> list[tuple[float, float, float]]:
    output = []
    n = particles.size() #length of the particles
    temp = [[0, 0, 0] for _ in range(n)]
    i = 0 #index1
    while(i < n):
        j = (i + 1) % n #index2
        curr = temp[i]
        pos1, _, _ = particles.at(i)
        while(j != i):
            pos2, q, _ = particles.at(j)
            vect = [pos1[0] - pos2[0], pos1[1] - pos2[1], pos1[2] - pos2[2]]
            distant = ((vect[0] ** 2) + (vect[1] ** 2) + (vect[2] ** 2)) ** 0.5
            unit_vect = [vect[0] / distant, vect[1] / distant, vect[2] / distant]
            e_mag = COULOMBS_CONSTANT * q / distant ** 2
            curr[0] += unit_vect[0] * e_mag
            curr[1] += unit_vect[1] * e_mag
            curr[2] += unit_vect[2] * e_mag
            j = (j + 1) % n
        i += 1
    for field in temp:
        output.append((field[0], field[1], field[2]))
    return output
    
#-------------------------------------------------------------------------------------------------------------------------------------------
# start by putting in the velocities at the step
step=0
vx_all, vy_all, vz_all=list(zip(vel_1[step],vel_2[step],vel_3[step]))
vx1, vy1, vz1=vx_all[0], vy_all[0], vz_all[0] # velocity of particle 1 @ t0
vx2, vy2, vz2=vx_all[1], vy_all[1], vz_all[1] # velocity of particle 2 @ t0
vx3, vy3, vz3=vx_all[2], vy_all[2], vz_all[2] # velocity of particle 3 @ t0

'''
Tom: The input format is not correct. solve_ivp won't take this.
'''
def find_pos_vel(velocity, fields, mass, charge): # input is the velocities @ t0 (beginning of step, and mass of the particle
    Force_E_ext=np.array(charge*fields[0][0], charge*fields[0][1], charge*fields[0][2]) # Fx, Fy, Fz for the external fields applied

    Force_B_ext=charge*np.cross(velocity, fields[2]) # F=q*(vÃ—B)
    
    Force_E_points=charge*fields[1] # multiplies the charge we're focusing on to the E field caused by the other charge (F=k*q_1*q_2/r^2)

    # net_force =Force_E_points+np.sqrt(Force_E_ext[0]**2+Force_E_ext[1]**2+Force_E_ext[2]**2)
    
    accel=net_force/mass
    return np.array(velocity[0], velocity[1], velocity[2], accel[0],accel[1], accel[2]) # returns v and a in all 3 dimensions at t0

'''
Tom: suggestion:
'''
def get_function(particles, get_fields):
    get_function.particles = particles
    get_function.get_fields = get_fields
    get_function.fields = get_function.get_fields(get_function.particles)
    def find_pos_vel(t: float, y: list[float], ext_field): #y: [pos_x1, pos_y1, post_z1, vel_x1, vel_y1, vel_z1, pos_x2, pos_y2....]
        output = []
        n = len(y) - 5
        i = 0
        while(i < n):
            particle_index = i // 6
            pos, q, m = get_function.particles.at(particle_index)
            output.append(y[i + 3])
            output.append(y[i + 4])
            output.append(y[i + 5])
            ext_x, ext_y, ext_z = ext_field(*pos)
            e_x, e_y, e_z = get_function.fields[particle_index]
            e_x += ext_x
            e_y = ext_y
            e_z += ext_z
            e_mag = (e_x ** 2 + e_y ** 2 + e_z ** 2) ** 0.5
            acc_mag = e_mag * q / m
            acc = (e_x * acc_mag / e_mag, e_y * acc_mag / e_mag, e_z * acc_mag / e_mag)
            output.append(acc[0])
            output.append(acc[1])
            output.append(acc[2])
            get_function.particles.update(particle_index, y[i], y[i + 1], y[i + 2])
            i += 6
        get_function.fields = get_function.get_fields(get_function.particles)
        return output
    return find_pos_vel
#-------------------------------------------------------------------------------------------------------------------------------------------
# now to use the ode function to find the positions and velocities at t1 (end of step)
'''
initial_state=(position, velocity) # positions and velocities at t0
wanted_times=(step[i-1], step[i]) # going from start of step to end of step (would need to update this at the end of each looping
answer=solve_ivp(find_pos_vel, y0=initial_state, method='RK45', t_span=wanted_times, rtol=1e-4) 
pos_1[1]=answer[0]
vel_1[1]=answer[1]
'''
# doing this for one single step (from i-1 (t0) to i(t1))

# we then would put this whole thing in a loop for every single step since after each step the positions/velocities change, which in turn 
# change the E and B fields
