# source for figuring out ode: https://flothesof.github.io/charged-particle-trajectories-E-and-B-fields.html

# general imports:
import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import scipy
from scipy.integrate import ode
from scipy.integrate import solve_ivp
from matplotlib import animation
from matplotlib.animation import FuncAnimation
from Particles import Particles # Particles class

COULOMBS_CONSTANT = 8.99*(10**9)
'''note: may have to change eventually for animation to make things easier--tbd'''

#-------------------------------------------------------------------------------------------------------------------------------------------
# ORIGINAL/BASE CODE:
# just for reference in case we need it, delete/store elsewhere before final project submission
'''
def get_fields(pos_part, pos_other1, pos_other2, q1, q_other1, q_other2, step): 
    # takes in the position of the desired particle (1xsteps*3), positions of the other particles and the other charges (Nx1)
    # and the step

    x_all, y_all, z_all=list(zip(pos_part[step],pos_other1[step],pos_other2[step]))
    # gives an array where the first set of 3 is x_1, x_2, x_3, the second set is y_1, y_2, y_3, last set is z_1, z_2, z_3 for desired time
    q_all=list([q1,q_other1,q_other2])
    
    x1, y1, z1=x_all[0], y_all[0], z_all[0] # position of desired particle (floats) @ t0
    xothers=np.array([x_all[1], x_all[2]]) # positions of the other particles in the system @ t0
    yothers=np.array([y_all[1], y_all[2]])
    zothers=np.array([z_all[1], z_all[2]])
 
    # here we define what we want E and B to be (that we're externally setting up)
    E_ext=np.array([1, (x1**2)+2, 2*y1]) # sample choice
    # B_ind= we reach steady state; cascates down the road and becomes complicated; if we don't include induced it's not going to be major
    # magentic fields that are induced are not conservative (this is a problem and have to deal with them differently, can't apply 
    # conservation laws
    B_ext=np.array([z1, 0, 3*x1]) # sample choice
    # E_ind=

    # we also need to consider the E fields being created by the other points
    E_points=0 # initially E from the other points is 0
    
    for particle in range(1, len(q_all)): # going through the other points generated and finding the field they create
        x2, y2, z2=xothers[particle-1], yothers[particle-1], zothers[particle-1] # go down one index b/c x others is already isolated to
                                                                                 # the non-desired particles
        q=q_all[particle]
        k=8.99*(10**9) # N*m^2/C--Coulomb's constant
        dist=np.sqrt(((x2-x1)**2)+((y2-y1)**2)+((z2-z1)**2))
        E_points+=k*q/(dist**2)
    # E_points that gets returned is the sum of all of the fields generated by the other particles
    
    return E_ext, B_ext, E_points # returns the fields at the start of the timestep (t0)

Fields1= get_fields(pos_1, pos_2, pos_3, q1, q2, q3, 0) # works as expected for Particle 1 so far--eventually put into particle loop and get all of them
Fields2= get_fields(pos_2, pos_3, pos_1, q2, q3, q1, 0) # works as expected for Particle 2 so far
Fields3= get_fields(pos_3, pos_1, pos_2, q3, q1, q2, 0) # works as expected for Particle 3

def find_pos_vel(velocity, fields, mass, charge): # input is the velocities @ t0 (beginning of step, and mass of the particle
    Force_E_ext=np.array(charge*fields[0][0], charge*fields[0][1], charge*fields[0][2]) # Fx, Fy, Fz for the external fields applied

    Force_B_ext=charge*np.cross(velocity, fields[2]) # F=q*(vÃ—B)
    
    Force_E_points=charge*fields[1] # multiplies the charge we're focusing on to the E field caused by the other charge (F=k*q_1*q_2/r^2)

    # net_force =Force_E_points+np.sqrt(Force_E_ext[0]**2+Force_E_ext[1]**2+Force_E_ext[2]**2)
    
    accel=net_force/mass
    return np.array(velocity[0], velocity[1], velocity[2], accel[0],accel[1], accel[2]) # returns v and a in all 3 dimensions at t0
'''
#--------------------------------------------------------------------------------------------------------------------
# NEW CODE (REVISED)--using Particles class just to simplify logistics of running through every particle in system

def get_fields2(particles: Particles) -> list[tuple[float, float, float]]:
    ''' calculates the electric field generated by each particle within our system '''
    output = []
    n = particles.size() #length of the particles
    temp = [[0, 0, 0] for _ in range(n)]
    i = 0 #index1
    while(i < n): # for every particle within the group of particles we give
        j = (i + 1) % n #index2
        curr = temp[i]
        pos1, _, _ = particles.at(i) # position of first particle
        while(j != i):
            pos2, q, _ = particles.at(j) # position of other particle
            vect = [pos1[0] - pos2[0], pos1[1] - pos2[1], pos1[2] - pos2[2]]
            distant = ((vect[0] ** 2) + (vect[1] ** 2) + (vect[2] ** 2)) ** 0.5 # distance between the particles
            unit_vect = [vect[0] / distant, vect[1] / distant, vect[2] / distant]
            e_mag = COULOMBS_CONSTANT * q / distant ** 2 # magnitude of the electric field produced
            curr[0] += unit_vect[0] * e_mag # E_x
            curr[1] += unit_vect[1] * e_mag # E_y
            curr[2] += unit_vect[2] * e_mag # E_z
            j = (j + 1) % n
        i += 1
    for field in temp:
        output.append((field[0], field[1], field[2])) # for each particle output the electric field (E_x, E_y, E_z)
    return output 
    
def get_function(particles, get_fields): 
    get_function.particles = particles # grabs the particles we're using
    get_function.get_fields = get_fields
    get_function.fields = get_function.get_fields(get_function.particles) # grabbing the fields for each particle
    def find_pos_vel(t: float, y: list[float], ext_field): #y: [pos_x1, pos_y1, post_z1, vel_x1, vel_y1, vel_z1, pos_x2, pos_y2....]
        ''' this is the function we'll ultimate use in solve_ivp to solve for the positions and velocities of each
            particle on every specified timestep
            
            - what's unique about this function is that with the following we can use solve_ivp on more than just
              one particle, and the electric/magnetic fields are constantly updated after each step simulate
              the true changing of fields as the particles move and accelerate'''
        output = []
        n = len(y) - 5
        i = 0
        while(i < n):
            particle_index = i // 6
            pos, q, m = get_function.particles.at(particle_index) # position, charge, mass of desired particle
            output.append(y[i + 3]) # appending to the output the particle's velocity
            output.append(y[i + 4])
            output.append(y[i + 5])
      
            # external electric and magnetic field:
            ext_x, ext_y, ext_z, b_ext_x, b_ext_y, b_ext_z = ext_field(*pos)
            e_x, e_y, e_z = get_function.fields[particle_index]
            e_x += ext_x # adding external and point fields together
            e_y = ext_y
            e_z += ext_z
            e_mag = (e_x ** 2 + e_y ** 2 + e_z ** 2) ** 0.5 # magnitude of net E fields

            # finding the accelerations:
            acc_mag_e = (e_mag * q / m)  
            acc_e = ((e_x * acc_mag_e / e_mag), (e_y * acc_mag_e / e_mag), (e_z * acc_mag_e / e_mag)) # acceleration from net E fields
            acc_b = (q/m) * np.cross([y[i + 3], y[i + 4], y[i + 5]], [b_ext_x, b_ext_y, b_ext_z]) # acceleration from B fields

            # incoporating a weak force (in the case of imminent collisions):
            '''Isabella: adding in weak force into play--work in progress
                         might end up switching the location of this in the function
                         
                         
                        NOTE: WILL HAVE TO MOVE THIS INTO GET_FIELDS FOR FUNCTION TO WORK'''
            if distant<=3: # for small enough distances between the particles (determine exact number later)
                acc_weak=(1/m)*(1/math.log(y[i]), 1/math.log(y[i+1]), 1/math.log(y[i+2])) # test force, arbitrary
                # acceleration that results from a sort of "weak force" applied so that the particle's don't collide
                ''' note: might need to figure out how to make this acceleration always oppose the direction of motion'''  
                acc_net= (acc_e[0]+acc_b[0]+acc_weak[0], acc_e[1]+acc_b[1]+acc_weak[1], acc_e[2]+acc_b[2]+acc_weak[2])
            else:
                acc_net= (acc_e[0]+acc_b[0], acc_e[1]+acc_b[1], acc_e[2]+acc_b[2]) # net acceleration from E and B fields on the particle
        
            output.append(acc_net[0]) # appending to the output the particle's acceleration (a_x, a_y, a_z)
            output.append(acc_net[1])
            output.append(acc_net[2])
            get_function.particles.update(particle_index, y[i], y[i + 1], y[i + 2])
            i += 6
        get_function.fields = get_function.get_fields(get_function.particles)
        return output # returns the velocities and accelerations for each particle in the system so that when
                      # put into solve_ivp we return the positions and velocities
    return find_pos_vel
#-------------------------------------------------------------------------------------------------------------------------------------------

