# source for figuring out ode: https://flothesof.github.io/charged-particle-trajectories-E-and-B-fields.html

# general imports:
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

import scipy
from scipy.integrate import ode
from scipy.integrate import solve_ivp
from matplotlib import animation
from matplotlib.animation import FuncAnimation 
#-------------------------------------------------------------------------------------------------------------------------------------------
# basically, we want to store a positions and velocities matrix for each particle we simulate
# setting things up (STARTING WITH 3 ARBITRARY PARTICLES):
'''eventually get to 5-6 particles'''
num_steps=10 # arbitrary
pos_1=np.zeros((num_steps, 3)) # array of positions for first particle for all timesteps
pos_1[0]=np.array([0, 0, 0]) # initial position of particle 1
vel_1=np.zeros((num_steps, 3)) # array of velocities for first particle for all timesteps
vel_1[0]=np.array([1, 1, 0]) # initial velocity of particle 1

pos_2=np.zeros((num_steps, 3))
pos_2[0]=np.array([1, 1, 0]) 
vel_2=np.zeros((num_steps, 3))
vel_2[0]=np.array([0, 0, 0])

pos_3=np.zeros((num_steps, 3))
pos_3[0]=np.array([0, 1, 1])
vel_3=np.zeros((num_steps, 3)) 
vel_3[0]=np.array([1, 0, 1])
#-------------------------------------------------------------------------------------------------------------------------------------------
''' eventually, all of the following will be put into a loop through each particle, which is nested in a larger
    loop for each time step'''

def get_fields(pos_part, pos_others, q_others): 
    ''' takes in the position of the desired particle (1x3), positions of the other N particles (Nx3) and the other charges (Nx1)
        would have to figure out a way to merge all the other particle's arrays together (np.concatenate) '''
    
    x1, y1, z1=pos_part[step,0], pos_part[step,1] , pos_part[step,2] 
    # take in the position at the beginning of each step of the desired particle
 
    # here we define what we want E and B to be (that we're externally setting up)
    E_ext=np.array(1, x1^2+2, 2*y1) # sample choice
    # B_ind= FIGURE THIS OUT
    B_ext=np.array(z1, 0, 3*x1) # sample choice
    # E_ind= FIGURE THIS OUT

    # we also need to consider the E fields being created by the other points
    E_points=0 # initially E from the other points is 0
    for other_particle in q_others: # going through the other points generated and finding the field they create
        x2, y2, z2=pos_others[step,0], pos_others[step,1] , pos_others[step,2]
        k=8.99*(10**9) # N*m^2/C
        distance=np.sqrt(((x2-x1)**2)+((y2-y1)**2)+((z2-z1)**2)) # distance between the 2 interacting points
        E_points+=k*q_others[other_particle]/(distance**2) # figure out how to specify the q in this to be q of other charges, not the one we're tracking  
    # E_points that gets returned is the sum of all of the fields generated by the other particles
    
    return E_ext, E_points, B_ext # returns the fields at the start of the timestep (t0)

#-------------------------------------------------------------------------------------------------------------------------------------------
# now we need to use these "starter fields" to help us get the next set of positions and velocities at (x1, y1, z1, v1):
def find_pos_vel(velocity, mass): # input is the velocities @ t0 (beginning of step, and mass of the particle
    Fields=get_fields(position, velocity) # also need the fields that we get from the get_fields function (also at t0)
    Force_E_ext=q*Fields[0] # F=q*E
    Force_E_points=q*Fields[1] # multiplies the charge we're focusing on to the E field caused by the other charge (F=k*q_1*q_2/r^2)
    Force_B_ext=q*np.cross(velocity,Fields[2]) # F=q*(vÃ—B)
    net_force=Force_E_ext+Force_E_points+Force_B_ext
    accel=net_force/mass
    return np.array(velocity[0], velocity[1], velocity[2], accel[0],accel[1], accel[2]) # returns v and a in all 3 dimensions at t0

#-------------------------------------------------------------------------------------------------------------------------------------------
# now to use the ode function to find the positions and velocities at t1 (end of step)
initial_state=(position, velocity) # positions and velocities at t0
wanted_times=(step[i-1], step[i]) # going from start of step to end of step (would need to update this at the end of each looping
answer=solve_ivp(find_pos_vel, y0=initial_state, method='RK45', t_span=wanted_times, rtol=1e-4) 
pos_1[1]=answer[0]
vel_1[1]=answer[1]
# doing this for one single step (from i-1 (t0) to i(t1))

# we then would put this whole thing in a loop for every single step since after each step the positions/velocities change, which in turn 
# change the E and B fields


#-------------------------------------------------------------------------------------------------------------------------------------------
'''ALTERNATIVE METHOD: USING CROSS PRODUCTS'''
# note: this section is a lot messier than the first attempt

# get this to run with something other that cross
initial_state=[position, velocity] # user input

def get_fields(position, velocity):
    dB_dt=___
    externalE=(x**2)+y+2*z # input
    k=22
    q=1 # input
    dE_dt=curl((externalE)+(k*q/(r**2)))
    
    return np.array(dB_dt, dE_dt) # -dB/dt, dE/dt


def setup(B, E):
    B=np.matrix([B]) # user input
    E=np.matrix([E])

    def get_x_v(t, [position, velocity], q, m):
    
        fields=solve_ivp(get_fields, y0=initial_state, method='RK45', t_span=(wanted_times[0],wanted_times[-1]), t_eval=wanted_times, rtol=1e-4) # solving using SHO equation again, using RK45 method
        B=fields[:,0] # updated one
        E=fields[:,1] # updated one

       
        return velocity, acceleration
    return get_x_v
    
f=setup([1,2,3],[4,5,6]) # set initial B and E


solve_ivp(f, y0=initial_state, method='RK45', t_span=(0,100), rtol=1e-4) # solving using SHO equation again, using RK45 method
